# -*- coding: utf-8 -*-
#
# Copyright © 2009-2010 Pierre Raybaut
# Licensed under the terms of the MIT License
# (see spyderlib/__init__.py for details)

"""
THIS IS NOT SIMPLE!!!

There are several important things here.

BaseTableModel - this stores a list of props dicts for each row
BaseTableView - this handles the actual rendering/interactions with BaseTableModel
BaseTableViewDelegate - this does some of the work that BaseTableView can't do itself


CustomTooltip - this subclasses QDialog, making it work like a giant tooltip
"""

#TODO: Multiple selection: open as many editors (array/dict/...) as necessary,
#      at the same time

# pylint: disable=C0103
# pylint: disable=R0903
# pylint: disable=R0911
# pylint: disable=R0201

from __future__ import print_function
from spyderlib.qt.QtGui import (QMessageBox, QTableView, QItemDelegate,
                                QLineEdit, QVBoxLayout, QWidget, QColor,
                                QDialog, QDateEdit, QDialogButtonBox, QMenu,
                                QInputDialog, QDateTimeEdit, QApplication,
                                QKeySequence, QAbstractItemDelegate, QLabel,
                                QToolTip, QHeaderView)
from spyderlib.qt.QtCore import (Qt, QModelIndex, QAbstractTableModel, Signal,
                                 QDateTime, Slot)
from spyderlib.qt.compat import to_qvariant, from_qvariant, getsavefilename
from spyderlib.utils.qthelpers import mimedata2url

import sys
import datetime

# Local import
from spyderlib.baseconfig import _
from spyderlib.guiconfig import get_font
from spyderlib.utils.misc import fix_reference_name
from spyderlib.utils.qthelpers import (get_icon, add_actions, create_action,
                                       qapplication)
from spyderlib.widgets.dicteditorutils import (sort_against, get_size,
               get_human_readable_type, value_to_display, get_color_name,
               is_known_type, FakeObject, Image, ndarray, array, MaskedArray,
               unsorted_unique, try_to_eval, datestr_to_datetime,
               get_numpy_dtype, is_editable_type, DataFrame, TimeSeries)
if ndarray is not FakeObject:
    from spyderlib.widgets.arrayeditor import ArrayEditor
if DataFrame is not FakeObject:
    from spyderlib.widgets.dataframeeditor import DataFrameEditor
from spyderlib.widgets.texteditor import TextEditor
from spyderlib.widgets.importwizard import ImportWizard
from spyderlib.py3compat import (to_text_string, to_binary_string,
                                 is_text_string, is_binary_string, getcwd, u)

from spyderlib.utils.makemetadict import make_meta_dict

LARGE_NROWS = 5000

def escape_for_html(s):
    return str(s).replace('&', '&amp;')\
                 .replace('<','&lt;')\
                 .replace('>','&gt;')
       

class BaseTableModel(QAbstractTableModel):
    """_data is a tuple, each item of which is a dict generated by
    get_basic_props in dictutils.  This dict contains the
    keys specified in ``column_keys`` (below) plus some other stuff.
    
    The job of this class is to map (row, col) to information that is needed
    such as display strings, colors, tooltip info etc.
    
    Note that although this is a "model", some of the information it offers
    is clearly more about rendering a view that raw "data" (e.g. colors).
    """
    
    # these are the keys into the properties dict corresponding to
    # columns 0,1,2,3
    columns_keys = ['key', 'type_str', 'size_str', 'value_str']
    column_header_names = {
        'key': _('name'),
        'type_str': _('type'),
        'size_str': _('size'),
        'value_str': _('value')
    }
    
    def __init__(self, parent, get_meta_dict_foo=lambda x: ()):
        QAbstractTableModel.__init__(self, parent)
        self._data = () # empty tuple
        
    def get_color_tuple(self, index, ignore_column=False):
        """Custom method used by Delegate.paint
        """
        if ignore_column or self.columns_keys[index.column()] == 'key':
            return self._data[index.row()]['flag_colors']
    
    def get_editor_switch(self, index, ignore_column=True):
        """Custom method used by Delegate.createEditor
        """
        if ignore_column or self.columns_keys[index.column()] == 'value':
            return self._data[index.row()]['editor_switch']
        
    def get_full_info(self, index):
        """Custom method used for generating tooltip text. 
        
        Although we could do basically all this work inside the get_meta_dict_foo, 
        we choose to do it here instead as it allows us a bit more control.
        """
        basic_props = self._data[index.row()]
        meta_props = get_meta_dict_foo(self.keys[row])
        
        value = basic_props['value_str']            
        if len(value) > 2000:
            value = value[:2000].rstrip() + "..." # QLabel strugles with long strings

        html_str = meta_str = value_str = "" 
        if 'html' in meta_props:
            if meta_props['html'] is not None:
                html_str = '<br><br>' + meta_props['html']
            del meta_props['html']
        if 'value' in meta_props:
            value = meta_props['value'] 
            del meta_props['value']
        if value is not None:
            value_str = "<br><br>" + escape_for_html(value)\
                                            .replace('\n','<br>')
        if len(meta_props) > 0:
            meta_str = '<br><br>'\
                + ' | '.join(["<b>%s:</b>&nbsp;%s"\
                              % (escape_for_html(k), escape_for_html(v)) \
                              for k, v in meta_dict.iteritems()])
                        
        return _("<h2>%s</h2><b>type:</b> %s | <b>size:</b> %s%s%s%s")\
                    % (basic_props['key'], basic_props['type_str'], basic_props['size_str'],
                       meta_str, html_str, value_str)
                    
    def columnCount(self, qindex=QModelIndex()):
        """Total number of displayable columns"""
        return len(self.columns_keys)
            
    def data(self, index, role=Qt.DisplayRole):
        """Implement BaseClass's method, to provide info about a given cell."""
        if not index.isValid():
            return to_qvariant()
        
        props = self._data[index.row()]
        
        if role == Qt.DisplayRole:
            return to_qvariant(props[self.column_keys[index.column()]])
        elif role == Qt.EditRole:
            raise NotImplementedError
        elif role == Qt.TextAlignmentRole:
            return to_qvariant(int(Qt.AlignLeft|Qt.AlignVCenter))
        elif role == Qt.FontRole:
            if self.column_keys[index.column()] == 'value_str':
                return to_qvariant(get_font('dicteditor'))
            else:
                return to_qvariant(get_font('dicteditor_header'))
        return to_qvariant()
    
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """Implement BaseClass's method to provide info about a given header"""
        if role == Qt.FontRole:
            return to_qvariant(get_font('dicteditor_header'))
        elif role == Qt.DisplayRole and orientation == Qt.Horizontal:
            i_column = int(section)
            return to_qvariant( 
                self.column_header_names[self.columns_keys[i_column]])
        else:
            return to_qvariant()

    def flags(self, index):
        """Implement BaseClass's method...?"""
        # This method was implemented in DictModel only, but to enable tuple
        # exploration (even without editing), this method was moved here
        if not index.isValid():
            return Qt.ItemIsEnabled
        return Qt.ItemFlags(QAbstractTableModel.flags(self, index)|
                            Qt.ItemIsEditable)
    def reset(self):
        self.beginResetModel()
        self.endResetModel()
        
        
        

class BaseTableView(QTableView):
    """Base dictionary editor table view"""
    sig_option_changed = Signal(str, object)
    sig_files_dropped = Signal(list)
    redirect_stdio = Signal(bool)
    
    def __init__(self, parent):
        QTableView.__init__(self, parent)
        self.array_filename = None
        self.menu = None
        self.empty_ws_menu = None
        self.paste_action = None
        self.copy_action = None
        self.edit_action = None
        self.plot_action = None
        self.hist_action = None
        self.imshow_action = None
        self.save_array_action = None
        self.insert_action = None
        self.remove_action = None
        self.truncate_action = None
        self.minmax_action = None
        self.rename_action = None
        self.duplicate_action = None
        self.delegate = None
        self.setAcceptDrops(True)
        self.info_pane = None 
        
        self.compact_mode_column= 0
        self.info_pane_index = None
                
    def showRequestedColumns(self):
        if self.compact:
            for col in xrange(self.model.columnCount()):
                if col != self.only_show_column:
                    self.setColumnHidden(col,True)
            self.horizontalHeader().setVisible(False)
        else:
            for col in xrange(self.model.columnCount()):
                self.setColumnHidden(col,False)  
            self.horizontalHeader().setVisible(True)
            
    def setModel(self, model):
        """Reimplement Qt method"""
        QTableView.setModel(self, model)
        self.showRequestedColumns()
        self.resizeRowsToContents()
            
    def setup_table(self):
        """Setup table"""
        self.horizontalHeader().setStretchLastSection(True)
        self.adjust_columns()
        # Sorting columns
        self.setSortingEnabled(True)
        self.sortByColumn(0, Qt.AscendingOrder)
    
    def setup_menu(self):
        """Setup context menu"""
        if self.truncate_action is not None:
            self.truncate_action.setChecked(self.model.truncate)
            self.minmax_action.setChecked(self.model.minmax)
            self.compact_action.setChecked(self.model.compact)
            return
        
        self.compact_action = create_action(self, _("Compact mode"),
                                            toggled=self.toggle_compact)
        self.compact_action.setChecked(self.model.compact)
        self.toggle_compact(self.model.compact)
        resize_action = create_action(self, _("Resize rows to contents"),
                                      triggered=self.resizeRowsToContents)
        self.paste_action = create_action(self, _("Paste"),
                                          icon=get_icon('editpaste.png'),
                                          triggered=self.paste)
        self.copy_action = create_action(self, _("Copy"),
                                         icon=get_icon('editcopy.png'),
                                         triggered=self.copy)                                      
        self.edit_action = create_action(self, _("Edit"),
                                         icon=get_icon('edit.png'),
                                         triggered=self.edit_item)
        self.plot_action = create_action(self, _("Plot"),
                                    icon=get_icon('plot.png'),
                                    triggered=lambda: self.plot_item('plot'))
        self.plot_action.setVisible(False)
        self.hist_action = create_action(self, _("Histogram"),
                                    icon=get_icon('hist.png'),
                                    triggered=lambda: self.plot_item('hist'))
        self.hist_action.setVisible(False)
        self.imshow_action = create_action(self, _("Show image"),
                                           icon=get_icon('imshow.png'),
                                           triggered=self.imshow_item)
        self.imshow_action.setVisible(False)
        self.save_array_action = create_action(self, _("Save array"),
                                               icon=get_icon('filesave.png'),
                                               triggered=self.save_array)
        self.save_array_action.setVisible(False)
        self.insert_action = create_action(self, _("Insert"),
                                           icon=get_icon('insert.png'),
                                           triggered=self.insert_item)
        self.remove_action = create_action(self, _("Remove"),
                                           icon=get_icon('editdelete.png'),
                                           triggered=self.remove_item)
        self.truncate_action = create_action(self, _("Truncate values"),
                                             toggled=self.toggle_truncate)
        self.truncate_action.setChecked(self.model.truncate)
        self.toggle_truncate(self.model.truncate)
        self.minmax_action = create_action(self, _("Show arrays min/max"),
                                           toggled=self.toggle_minmax)
        self.minmax_action.setChecked(self.model.minmax)
        self.toggle_minmax(self.model.minmax)
        self.rename_action = create_action(self, _( "Rename"),
                                           icon=get_icon('rename.png'),
                                           triggered=self.rename_item)
        self.duplicate_action = create_action(self, _( "Duplicate"),
                                              icon=get_icon('edit_add.png'),
                                              triggered=self.duplicate_item)
        menu = QMenu(self)
        menu_actions = [self.edit_action, self.plot_action, self.hist_action,
                        self.imshow_action, self.save_array_action,
                        self.insert_action, self.remove_action,
                        self.copy_action, self.paste_action,
                        None, self.rename_action, self.duplicate_action,
                        None, resize_action, self.compact_action,
                        None, self.truncate_action,
                        ]
        if ndarray is not FakeObject:
            menu_actions.append(self.minmax_action)
        add_actions(menu, menu_actions)
        self.empty_ws_menu = QMenu(self)
        add_actions(self.empty_ws_menu,
                    [self.insert_action, self.paste_action,
                     None, resize_action, None, self.compact_action])
        return menu
            
    #---------------------------------------------------------------------------
            
    def refresh_menu(self):
        """Refresh context menu"""
        index = self.currentIndex()
        condition = index.isValid()
        self.edit_action.setEnabled( condition )
        self.remove_action.setEnabled( condition )
        self.refresh_plot_entries(index)
        
    def refresh_plot_entries(self, index):
        if index.isValid():
            key = self.model.get_key(index)
            is_list = self.is_list(key)
            is_array = self.is_array(key) and self.get_len(key) != 0
            condition_plot = (is_array and len(self.get_array_shape(key)) <= 2)
            condition_hist = (is_array and self.get_array_ndim(key) == 1)
            condition_imshow = condition_plot and self.get_array_ndim(key) == 2
            condition_imshow = condition_imshow or self.is_image(key)
        else:
            is_array = condition_plot = condition_imshow = is_list \
                     = condition_hist = False
        self.plot_action.setVisible(condition_plot or is_list)
        self.hist_action.setVisible(condition_hist or is_list)
        self.imshow_action.setVisible(condition_imshow)
        self.save_array_action.setVisible(is_array)
        
    def adjust_columns(self):
        """Resize two first columns to contents"""
        for col in range(3):
            self.resizeColumnToContents(col)
        
    def set_data(self, data):
        """Set table data"""
        if data is not None:
            self.model.set_data(data, self.dictfilter)
            self.sortByColumn(0, Qt.AscendingOrder)
            
    def enterEvent(self,event):
        """Reimplement Qt method"""
        if self.model.compact:
            self.info_pane.show()
            self.info_pane.showText("")
            self.info_pane_index = None
        QTableView.enterEvent(self,event)
        
    def leaveEvent(self,event):
        """Reimplement Qt method"""
        if self.model.compact:
            self.info_pane.hide()
        self.info_pane_index = None
        QTableView.leaveEvent(self,event)
        
    def mouseMoveEvent(self, event):
        """Reimplement Qt method"""
        if self.compact:            
            index_over = self.indexAt(event.pos())
            if index_over.isValid() and index_over.row() != self.info_pane_index:
                self.info_pane.showText(index_over.model().get_full_info(index_over))
                self.info_pane_index = index_over.row()
            QTableView.mouseMoveEvent(self, event)
        
    def mousePressEvent(self, event):
        """Reimplement Qt method"""
        if event.button() != Qt.LeftButton:
            QTableView.mousePressEvent(self, event)
            return
        index_clicked = self.indexAt(event.pos())
        if index_clicked.isValid():
            if index_clicked == self.currentIndex() \
               and index_clicked in self.selectedIndexes():
                self.clearSelection()
            else:
                QTableView.mousePressEvent(self, event)
        else:
            self.clearSelection()
            event.accept()
    
    def mouseDoubleClickEvent(self, event):
        """Reimplement Qt method"""
        index_clicked = self.indexAt(event.pos())
        if index_clicked.isValid():
            row = index_clicked.row()
            # TODO: Remove hard coded "Value" column number (3 here)
            index_clicked = index_clicked.child(row, self.only_show_column
                                                 if self.model.compact else 3)
            self.edit(index_clicked)
        else:
            event.accept()
    
    def keyPressEvent(self, event):
        """Reimplement Qt methods"""
        if event.key() == Qt.Key_Delete:
            self.remove_item()
        elif event.key() == Qt.Key_F2:
            self.rename_item()
        elif event == QKeySequence.Copy:
            self.copy()
        elif event == QKeySequence.Paste:
            self.paste()
        else:
            QTableView.keyPressEvent(self, event)
        
    def contextMenuEvent(self, event):
        """Reimplement Qt method"""
        if self.model.showndata:
            self.refresh_menu()
            self.menu.popup(event.globalPos())
            event.accept()
        else:
            self.empty_ws_menu.popup(event.globalPos())
            event.accept()

    @Slot(bool)
    def toggle_compact(self, state):
        """Toggle compact view"""
        self.sig_option_changed.emit('compact', state)
        self.model.compact = state
        self.setMouseTracking(state)
        if self.info_pane is None and state:
            self.info_pane = InfoPane(self)
        if state:
            self.toggle_truncate(False)
            self.info_pane.update_position()
            self.verticalHeader().setResizeMode(QHeaderView.ResizeToContents)
        else:
            self.verticalHeader().setResizeMode(QHeaderView.Interactive)
            
        self.showRequestedColumns()
        self.resizeColumnsToContents()
        
    @Slot()
    def edit_item(self):
        """Edit item"""
        index = self.currentIndex()
        if not index.isValid():
            return
        # TODO: Remove hard coded "Value" column number (3 here)
        self.edit(index.child(index.row(), 
                              self.compact_mode_columnif self.model.compact\
                              else 3))


            
class BaseTableViewDelegate(QItemDelegate):
    """BaseTableView uses this class to handle the view/intereactions for
    individual cells in the table.

    Specifically, it handles the custom painting of cells, and the launching 
    of the editor and subsequent updating of values.
    """
    def __init__(self, parent=None):
        QItemDelegate.__init__(self, parent)
           
    def paint(self, painter, options, index):
        """Reimplement Qt method"""
        model = index.model()
        color_tuple = model.get_color_tuple(index)
        if color_tuple and len(color_tuple) > 0:
            painter.save()
            rect = options.rect
            w = 4
            for ii, c in enumerate(color_tuple):
                painter.fillRect(rect.right()-(ii+1)*w,rect.top(),w, rect.height(),
                             QColor(c))
            painter.restore()
        QItemDelegate.paint(self, painter, options, index)
        
    def createEditor(self, parent, option, index):
        """Reimplement Qt method"""
        model = index.model()
        editor_switch = model.get_editor_switch(index)
        raise NotImplementedError
            
            

class CustomTooltip(QDialog):
    def __init__(self, parent):
        QDialog.__init__(self, parent)
        self.setAttribute(Qt.WA_DeleteOnClose | Qt.WA_ShowWithoutActivating)        
        vlayout = QVBoxLayout()
        self.main_text = QLabel()
        self.main_text.setWordWrap(True)        
        vlayout.addWidget(self.main_text)
        self.setLayout(vlayout)
        self.update_position()
        
        # Style the dialog to look like a tooltip (more or less)
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint \
                            | Qt.WindowStaysOnTopHint) 
        self.setWindowOpacity(0.9)        
        self.setPalette(QToolTip.palette())
        self.setStyleSheet("QDialog {border: 1px solid black}")

    def update_position(self):
        left = 0
        top = 0
        parent = self.parent()
        geo = parent.geometry()
        parent_width = geo.width()
        self_width = 380        
        self_height = 300        
        self.setMinimumSize(self_width, self_height)                
        self.setMaximumSize(self_width, self_height)
        while parent:
            geo = parent.geometry()
            top += geo.top()
            left += geo.left()
            parent = parent.parent()
        window_width = geo.width()

        # Work out whether there is more space to the left or right of the parent
        right_space = window_width - (left + parent_width)    
        if right_space > left:
            left += parent_width
            self.main_text.setAlignment(Qt.AlignTop \
                                    | Qt.AlignLeft)
        else:
            left -= self_width
            self.main_text.setAlignment(Qt.AlignTop \
                                    | Qt.AlignRight)
        self.move(left, top) 

    def showText(self, text):
        # Note that we really out to hook into the move/resize events of all
        # the ancestors of this widget, but instead we just do this update here
        self.update_position()  
        self.main_text.setText(text)
        self.setVisible(len(text) > 0)
        


#-----TEST TEST TEST TEST ----------------------------------------------------

if __name__ == "__main__":
    
    def get_test_data():
        """Create test data"""
        import numpy as np
        from spyderlib.pil_patch import Image
        image = Image.fromarray(np.random.random_integers(255, size=(100, 100)),
                                mode='P')
        testdict = {'d': 1, 'a': np.random.rand(10, 10), 'b': [1, 2]}
        testdate = datetime.date(1945, 5, 8)
        class Foobar(object):
            def __init__(self):
                self.text = "toto"
                self.testdict = testdict
                self.testdate = testdate
        foobar = Foobar()
        return {'object': foobar,
                'str': 'kjkj kj k j j kj k jkj',
                'unicode': to_text_string('éù', 'utf-8'),
                'list': [1, 3, [sorted, 5, 6], 'kjkj', None],
                'tuple': ([1, testdate, testdict], 'kjkj', None),
                'dict': testdict,
                'float': 1.2233,
                'int': 223,
                'bool': True,
                'array': np.random.rand(10, 10),
                'masked_array': np.ma.array([[1, 0], [1, 0]],
                                            mask=[[True, False], [False, False]]),
                '1D-array': np.linspace(-10, 10),
                'empty_array': np.array([]),
                'image': image,
                'date': testdate,
                'datetime': datetime.datetime(1945, 5, 8),
                'complex': 2+1j,
                'complex64': np.complex64(2+1j),
                'int8_scalar': np.int8(8),
                'int16_scalar': np.int16(16),
                'int32_scalar': np.int32(32),
                'bool_scalar': np.bool(8),
                'unsupported1': np.arccos,
                'unsupported2': np.cast,
                #1: (1, 2, 3), -5: ("a", "b", "c"), 2.5: np.array((4.0, 6.0, 8.0)),            
                }
    
    def test():
        """Dictionary editor test"""
        app = qapplication() #analysis:ignore
        dialog = DictEditor()
        dialog.setup(get_test_data())
        dialog.show()
        app.exec_()
        print("out:", dialog.get_value())
        
    def remote_editor_test():
        """Remote dictionary editor test"""
        from spyderlib.plugins.variableexplorer import VariableExplorer
        from spyderlib.widgets.externalshell.monitor import make_remote_view
        remote = make_remote_view(get_test_data(), VariableExplorer.get_settings())
        from pprint import pprint
        pprint(remote)
        app = qapplication()
        dialog = DictEditor()
        dialog.setup(remote, remote=True)
        dialog.show()
        app.exec_()
        if dialog.result():
            print(dialog.get_value())
        
    remote_editor_test()
