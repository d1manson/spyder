# -*- coding: utf-8 -*-
#
# Copyright Â© 2009-2010 Pierre Raybaut
# Licensed under the terms of the MIT License
# (see spyderlib/__init__.py for details)

"""
THIS IS NOT SIMPLE!!!

There are several important things here.

BaseTableModel - this stores a list of props dicts for each row
BaseTableView - this handles the actual rendering/interactions with BaseTableModel
BaseTableViewDelegate - this does some of the work that BaseTableView can't do itself


CustomTooltip - this subclasses QDialog, making it work like a giant tooltip
"""

#TODO: Multiple selection: open as many editors (array/dict/...) as necessary,
#      at the same time

# pylint: disable=C0103
# pylint: disable=R0903
# pylint: disable=R0911
# pylint: disable=R0201

from __future__ import print_function
from spyderlib.qt.QtGui import (QMessageBox, QTableView, QItemDelegate,
                                QLineEdit, QVBoxLayout, QWidget, QColor,
                                QDialog, QDateEdit, QDialogButtonBox, QMenu,
                                QInputDialog, QDateTimeEdit, QApplication,
                                QKeySequence, QAbstractItemDelegate, QLabel,
                                QToolTip, QHeaderView, QDockWidget)
from spyderlib.qt.QtCore import (Qt, QModelIndex, QAbstractTableModel, Signal,
                                 QDateTime, Slot, QObject)
from spyderlib.qt.compat import to_qvariant, from_qvariant, getsavefilename
from spyderlib.utils.qthelpers import mimedata2url
from spyderlib.widgets.externalshell.monitor import communicate
import sys
import datetime

# Local import
from spyderlib.baseconfig import _
from spyderlib.guiconfig import get_font
from spyderlib.utils.misc import fix_reference_name
from spyderlib.utils.qthelpers import (get_icon, add_actions, create_action,
                                       qapplication)
from spyderlib.widgets.dicteditorutils import (sort_against,
               unsorted_unique)
from spyderlib.widgets.texteditor import TextEditor
from spyderlib.widgets.importwizard import ImportWizard
from spyderlib.py3compat import (to_text_string, to_binary_string,
                                 is_text_string, is_binary_string, getcwd, u)

from spyderlib.utils.makemetadict import make_meta_dict

LARGE_NROWS = 5000

def escape_for_html(s):
    return str(s).replace('&', '&amp;')\
                 .replace('<','&lt;')\
                 .replace('>','&gt;')
       

class BaseTableModel(QAbstractTableModel):
    """_data is a tuple, each item of which is a dict generated by
    get_basic_props in dictutils.  This dict contains the
    keys specified in ``column_keys`` (below) plus some other stuff.
    
    The _data corresponds to the ``key_path`` tuple, which defines how to 
    traverse from the root namespace down to a particular dict/list etc.
    
    The job of this class is to map (row, col) to information that is needed
    such as display strings, colors, tooltip info, edit mode etc.
    
    Note that although this is a "model", some of the information it offers
    is clearly more about rendering a view that raw "data" (e.g. colors).
    
    When this model needs to evaluate something, e.g. getting meta_dict,
    it does it using ``self.command('get_meta_dict', key)``. This may
    be executed locally, or it may be executed via monitor.py.  In both
    cases it is synchronous (i.e. it stalls until the answer is received).
    """
    
    # these are the keys into the properties dict corresponding to
    # columns 0,1,2,3
    columns_keys = ['key', 'type_str', 'size_str', 'value_str']
    column_header_names = {
        'key': _('name'),
        'type_str': _('type'),
        'size_str': _('size'),
        'value_str': _('value')
    }
    
    def __init__(self, parent, communicate, key_path=(), data=()):
        QAbstractTableModel.__init__(self, parent)
        self._data = sorted(data, key=lambda props: props['key'].lower())
        self.key_path = key_path or () # if key_path was None
        self.communicate = communicate
        
    def get_color_tuple(self, index, ignore_column=False):
        """Custom method used by Delegate.paint
        """
        if ignore_column or self.columns_keys[index.column()] == 'key':
            return self._data[index.row()]['flag_colors']
    
    def get_editor_switch(self, index, ignore_column=True):
        """Custom method used by Delegate.createEditor
        """
        if ignore_column or self.columns_keys[index.column()] == 'value':
            return self._data[index.row()]['editor_switch']
        
    def get_full_info(self, index):
        """Custom method used for generating tooltip text. 
        
        Although we could do basically all this work inside the get_meta_dict_foo, 
        we choose to do it here instead as it allows us a bit more control.
        """
        basic_props = self._data[index.row()]
        cmd = 'get_meta_dict(%s)' % str((self.key_path + (basic_props['key'],)))
        meta_props = self.communicate(cmd)
        
        value = basic_props['value_str']            
        html_str = meta_str = "" 
        if 'html' in meta_props:
            if meta_props['html'] is not None:
                html_str = '<br><br>' + meta_props['html']
            del meta_props['html']
        if 'value' in meta_props:
            value = meta_props['value'] 
            del meta_props['value']
        if value is None:
            value_str = ""
        else:
            if len(value) > 2000:
                value = value[:2000].rstrip() + "..." # QLabel strugles with long strings
            value_str = "<br><br>" + escape_for_html(value)\
                                            .replace('\n','<br>')
        
        if len(meta_props) > 0:
            meta_str = '<br><br>'\
                + ' | '.join(["<b>%s:</b>&nbsp;%s"\
                              % (escape_for_html(k), escape_for_html(v)) \
                              for k, v in meta_props.iteritems()])
                        
        return _("<h2>%s</h2><b>type:</b> %s | <b>size:</b> %s%s%s%s")\
                    % (basic_props['key'], basic_props['type_str'], basic_props['size_str'],
                       meta_str, html_str, value_str)
                    
    def columnCount(self, qindex=QModelIndex()):
        """Implement BaseClass's abstract method.
        Total number of displayable columns"""
        return len(self.columns_keys)

    def rowCount(self, qindex=QModelIndex()):
        """Implement BaseClass's abstract method.
        Total number of displayable rows"""
        return len(self._data)
        
    def data(self, index, role=Qt.DisplayRole):
        """Implement BaseClass's method, to provide info about a given cell."""
        if not index.isValid():
            return to_qvariant()
            
        props = self._data[index.row()]
        if role == Qt.DisplayRole:
            return to_qvariant(props[self.columns_keys[index.column()]])
        elif role == Qt.EditRole:
            raise NotImplementedError
        elif role == Qt.TextAlignmentRole:
            return to_qvariant(int(Qt.AlignLeft|Qt.AlignVCenter))
        elif role == Qt.FontRole:
            if self.columns_keys[index.column()] == 'value_str':
                return to_qvariant(get_font('dicteditor'))
            else:
                return to_qvariant(get_font('dicteditor_header'))
        return to_qvariant()
    
    def headerData(self, section, orientation, role=Qt.DisplayRole):
        """Implement BaseClass's method to provide info about a given header"""
        if role == Qt.FontRole:
            return to_qvariant(get_font('dicteditor_header'))
        elif role == Qt.DisplayRole and orientation == Qt.Horizontal:
            i_column = int(section)
            return to_qvariant( 
                self.column_header_names[self.columns_keys[i_column]])
        else:
            return to_qvariant()
            
    def reset(self):
        self.beginResetModel()
        self.endResetModel()
        
        
        

class BaseTableView(QTableView):
    """This holds a BaseTableModel and makes it possible to render/interact 
    with it.  Stuff for individual cells is handled by BaseTableViewDelegate"""
    sig_option_changed = Signal(str, object)
    
    def __init__(self, parent):
        QTableView.__init__(self, parent)
        self.setItemDelegate(BaseTableViewDelegate(self))
        self.horizontalHeader().setStretchLastSection(True)
        self.custom_tooltip = None 
        self.tooltip_index = None
        self.compact_mode_column = 0
        self.compact = True
        self.only_show_column = 'key'
        self.compact_action = create_action(self, _("Compact mode"),
                                            toggled=self.toggle_compact)
        self.compact_action.setChecked(self.compact)
        self.toggle_compact(self.compact)
        menu_actions = [self.compact_action]
        self.menu = QMenu(self)
        add_actions(self.menu, menu_actions)
        
        
    def showRequestedColumns(self):
        model = self.model()
        if model is None:
            return
        if self.compact:
            for col_idx, col_key in enumerate(model.columns_keys):
                if col_key != self.only_show_column:
                    self.setColumnHidden(col_idx, True)
            self.horizontalHeader().setVisible(False)
        else:
            for col_idx, _ in enumerate(model.columns_keys):
                self.setColumnHidden(col_idx, False)  
            self.horizontalHeader().setVisible(True)
            
    def setModel(self, model):
        """Reimplement Qt method"""
        QTableView.setModel(self, model)
        self.showRequestedColumns()
        self.resizeRowsToContents()
            
    def setup_table(self):
        """Setup table"""
        self.horizontalHeader().setStretchLastSection(True)
        self.adjust_columns()

        self.setSortingEnabled(True)
        self.sortByColumn(0, Qt.AscendingOrder)
            
    def enterEvent(self,event):
        """Reimplement Qt method"""
        if self.compact:
            self.custom_tooltip.showText("")
            self.tooltip_index = None
        QTableView.enterEvent(self,event)
        
    def leaveEvent(self,event):
        """Reimplement Qt method"""
        if self.compact:
            self.custom_tooltip.hide()
        self.tooltip_index = None
        QTableView.leaveEvent(self, event)
        
    def mouseMoveEvent(self, event):
        """Reimplement Qt method"""
        if self.compact:            
            index_over = self.indexAt(event.pos())
            if index_over.isValid() and index_over.row() != self.tooltip_index:
                self.custom_tooltip.showText(index_over.model().get_full_info(index_over))
                self.tooltip_index = index_over.row()
            QTableView.mouseMoveEvent(self, event)
        
    def mousePressEvent(self, event):
        """Reimplement Qt method"""
        if event.button() != Qt.LeftButton:
            QTableView.mousePressEvent(self, event)
            return
        index_clicked = self.indexAt(event.pos())
        if index_clicked.isValid():
            if index_clicked == self.currentIndex() \
               and index_clicked in self.selectedIndexes():
                self.clearSelection()
            else:
                QTableView.mousePressEvent(self, event)
        else:
            self.clearSelection()
            event.accept()
    
    def mouseDoubleClickEvent(self, event):
        """Reimplement Qt method"""
        index_clicked = self.indexAt(event.pos())
        if index_clicked.isValid():
            row = index_clicked.row()
            # TODO: Remove hard coded "Value" column number (3 here)
            index_clicked = index_clicked.child(row, self.only_show_column
                                                 if self.compact else 3)
            self.edit(index_clicked)
        else:
            event.accept()
    
    def keyPressEvent(self, event):
        """Reimplement Qt methods"""
        if event.key() == Qt.Key_Delete:
            self.remove_item()
        elif event.key() == Qt.Key_F2:
            self.rename_item()
        elif event == QKeySequence.Copy:
            self.copy()
        elif event == QKeySequence.Paste:
            self.paste()
        else:
            QTableView.keyPressEvent(self, event)
        
    def contextMenuEvent(self, event):
        """Reimplement Qt method"""
        # index_clicked = self.indexAt(event.pos())
        # TODO: customise menu based on index
        self.menu.popup(event.globalPos())
        event.accept()

    @Slot(bool)
    def toggle_compact(self, state):
        """Toggle compact view"""
        self.sig_option_changed.emit('compact', state)
        self.compact = state
        self.setMouseTracking(state)
        if self.custom_tooltip is None and state:
            self.custom_tooltip = CustomTooltip(self)
        self.verticalHeader().setResizeMode(
            QHeaderView.ResizeToContents if state else QHeaderView.Interactive)            
        self.showRequestedColumns()
        self.resizeColumnsToContents()
        
    @Slot()
    def edit_item(self):
        """Edit item"""
        index = self.currentIndex()
        if not index.isValid():
            return
        raise NotImplementedError

            
class BaseTableViewDelegate(QItemDelegate):
    """BaseTableView uses this class to handle the view/intereactions for
    individual cells in the table.

    Specifically, it handles the custom painting of cells, and the launching 
    of the editor and subsequent updating of values.
    """
    def __init__(self, parent=None):
        QItemDelegate.__init__(self, parent)
           
    def paint(self, painter, options, index):
        """Reimplement Qt method"""
        model = index.model()
        color_tuple = model.get_color_tuple(index)
        if color_tuple and len(color_tuple) > 0:
            painter.save()
            rect = options.rect
            w = 4
            left = rect.right() - len(color_tuple)*w
            for ii, c in enumerate(color_tuple):
                painter.fillRect(left + ii*w,rect.top(),w, rect.height(),
                             QColor(c))
            painter.restore()
        QItemDelegate.paint(self, painter, options, index)
        
    def createEditor(self, parent, option, index):
        """Reimplement Qt method"""
        raise NotImplementedError 
        """               
        model = index.model()
        editor_switch = self.model.get_editor_switch(index)
        """ 
            

class CustomTooltip(QDialog):
    def __init__(self, parent):
        QDialog.__init__(self, parent)
        self.setAttribute(Qt.WA_DeleteOnClose | Qt.WA_ShowWithoutActivating)        
        vlayout = QVBoxLayout()
        self.main_text = QLabel()
        self.main_text.setWordWrap(True)        
        vlayout.addWidget(self.main_text)
        self.setLayout(vlayout)
        self.update_position()
        
        # Style the dialog to look like a tooltip (more or less)
        self.setWindowFlags(Qt.Tool | Qt.FramelessWindowHint \
                            | Qt.WindowStaysOnTopHint) 
        self.setWindowOpacity(0.9)        
        self.setPalette(QToolTip.palette())
        self.setStyleSheet("QDialog {border: 1px solid black}")

    def update_position(self):
        left = 0
        top = 0
        parent = self.parent()
        geo = parent.geometry()
        parent_width = geo.width()
        self_width = 380        
        self_height = 300        
        self.setMinimumSize(self_width, self_height)                
        self.setMaximumSize(self_width, self_height)
        while parent:
            geo = parent.geometry()
            top += geo.top()
            left += geo.left()
            parent = parent.parent()
        window_width = geo.width()

        # Work out whether there is more space to the left or right of the parent
        right_space = window_width - (left + parent_width)    
        if right_space > left:
            left += parent_width
            self.main_text.setAlignment(Qt.AlignTop \
                                    | Qt.AlignLeft)
        else:
            left -= self_width
            self.main_text.setAlignment(Qt.AlignTop \
                                    | Qt.AlignRight)
        self.move(left, top) 

    def showText(self, text):
        # Note that we really out to hook into the move/resize events of all
        # the ancestors of this widget, but instead we just do this update here
        self.update_position()  
        self.main_text.setText(text)
        self.setVisible(len(text) > 0)
        
        
from spyderlib.plugins.variableexplorer import (VariableExplorerConfigPage, 
    SpyderPluginMixin)

class ShellWrapper():
    """ShellWrapper holds reference to a shell (e.g. an IPython shell.)
    It knows how to send commands to the shell and get answers back.
    """
    def __init__(self, shell):
        """shell is a shellwidget"""
        from spyderlib.widgets import internalshell
        self.shell = shell
        self.shell_id = id(shell)
        self.is_internal = isinstance(shell, internalshell.InternalShell),
        self.is_ipykernel = shell.is_ipykernel
        
    def communicate(self, command, settings={}):
        """Sends a command to the shell and gets return value.
        See monitor.py for available commands and meanings.        
        """
        socket = self.shell.introspection_socket
        if socket is not None:
            return communicate(socket, command, settings)
            
class VariableExplorer(QWidget, SpyderPluginMixin):
    """
    Variable Explorer Plugin. It is the outermost widget. For now it simply
    holds a single BaseTableView, stored in self.editor.
    """
    CONF_SECTION = 'variable_explorer'
    CONFIGWIDGET_CLASS = VariableExplorerConfigPage
    sig_option_changed = Signal(str, object)

    def __init__(self, parent):
        QWidget.__init__(self, parent)
        SpyderPluginMixin.__init__(self, parent)
        self.initialize_plugin()
        self.editor = BaseTableView(self)
        vlayout = QVBoxLayout()
        vlayout.addWidget(self.editor)
        self.setLayout(vlayout)
        self.refresh_table()
        self.id_to_shell_wrapper = {}

    def refresh_table(self):
        pass

    def set_shellwidget_from_id(self, id_):
        if id_ in self.id_to_shell_wrapper:
            comminicate_foo = self.id_to_shell_wrapper[id_].communicate 
            root_data = comminicate_foo('get_props_for_variable_explorer()')
            if root_data is not None:
                model = BaseTableModel(self.editor, comminicate_foo,
                                       None, root_data)
                self.editor.setModel(model)
            
    def add_shellwidget(self, shell):
        self.id_to_shell_wrapper[id(shell)] = ShellWrapper(shell) 

    #------ SpyderPluginWidget API ---------------------------------------------
    def get_plugin_title(self):
        """Return widget title"""
        return _('Variable explorer')

    def get_plugin_icon(self):
        """Return plugin icon"""
        return get_icon('dictedit.png')
    
    def get_focus_widget(self):
        """
        Return the widget to give focus to when
        this plugin's dockwidget is raised on top-level
        """
        return self.editor
        
    def closing_plugin(self, cancelable=False):
        """Perform actions before parent main window is closed"""
        return True
        
    def refresh_plugin(self):
        """Refresh widget"""
        pass
    
    def get_plugin_actions(self):
        """Return a list of actions related to plugin"""
        return []
    
    def register_plugin(self):
        """Register plugin in Spyder's main window"""
        self.main.extconsole.set_variableexplorer(self)
        self.main.add_dockwidget(self)
                  

